
- Specify that challenge e also has modulus bias!
- Domain hash encoding? Ethereum Signed Message?
    - Study EIP-712 signTypedData
    - Should not be part of EIP, eth_sign and eth_typesSign exist and both are ok.
        - However, need analysis in doc, also to educate
- Will contract signatures work?
- Serialization
    - Not part of EIP! EIP only defines PK as input, not where its coming from
        - However, provide benchmarks from crysol to educate
        - Note to mention that signatures should NEVER be used as identifiers!
        - Compressed only needs 1 precompile call! Very attractive for 32 bytes calldata savings
    - Benchmark compressed calldata savings vs uncompressed runtime savings
- Nonce is deterministic
    - NOT via RFC-6979 though, too complex
    - RFC provides good reasoning in intro though
    - EdDSA “basically” just uses H(x || m)
    - Need mechanism for nonce not suitable. Could say module and accept risk, however, better to use H(x || m || ctr)?
        - This allows same nonce mechanism for possible p256 schnorr implementation?
    - NOTE: We accept the bias anyway already though, during challenge construction
    - What about Poseidon hash? Need to be future proof for zk?
- Should EIP directly also define for r1?
    - Is modulo bias also ok for r1?
    - Write proof for r1 precompile mulVerify
